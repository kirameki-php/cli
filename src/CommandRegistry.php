<?php declare(strict_types=1);

namespace Kirameki\Cli;

use Kirameki\Cli\Exceptions\CommandNotFoundException;
use Kirameki\Cli\Exceptions\DuplicateEntryException;
use Kirameki\Container\Container;
use function array_diff;
use function array_key_exists;
use function array_keys;
use function class_exists;
use function count;
use function file_exists;
use function file_put_contents;
use function implode;
use function is_subclass_of;
use function mkdir;
use function var_export;

class CommandRegistry
{
    /**
     * @var array<class-string<Command>, null>
     */
    protected array $registeredSet = [];

    /**
     * @var array<string, class-string<Command>>
     */
    protected array $aliasMap = [];

    /**
     * @param Container $container
     * @param string $cacheDir
     * @param bool $devMode
     */
    public function __construct(
        protected readonly Container $container,
        protected readonly string $cacheDir = '/tmp/kirameki',
        protected readonly bool $devMode = false,
    )
    {
    }

    /**
     * @param class-string<Command> $command
     * @return $this
     */
    public function register(string $command): static
    {
        if ($this->registered($command)) {
            throw new DuplicateEntryException($command, [
                'command' => $command,
            ]);
        }

        $this->registeredSet[$command] = null;

        return $this;
    }

    /**
     * @param string|class-string<Command> $name
     * @return bool
     */
    public function registered(string $name): bool
    {
        return array_key_exists($name, $this->registeredSet);
    }

    /**
     * @return string
     */
    public function getAliasMapCachePath(): string
    {
        return $this->cacheDir . '/command-aliases.php';
    }

    /**
     * @param string|class-string<Command> $name
     * @return Command
     */
    public function makeCommand(string $name): Command
    {
        return $this->container->make($this->getCommandClass($name));
    }

    /**
     * @param string|class-string<Command> $name
     * @return class-string<Command>
     */
    protected function getCommandClass(string $name): string
    {
        // if the actual class name is given, just return it
        if (class_exists($name) && is_subclass_of($name, Command::class)) {
            return $name;
        }

        // Instantiate the commands once to get the alias names of all the commands.
        $this->syncAliasMap();

        if (array_key_exists($name, $this->aliasMap)) {
            return $this->aliasMap[$name];
        }

        throw new CommandNotFoundException("Command: {$name} is not registered.", [
            'name' => $name,
            'registered' => array_keys($this->registeredSet),
        ]);
    }

    /**
     * @return void
     */
    public function syncAliasMap(): void
    {
        $fileFound = $this->importAliasMap();

        if ($fileFound && !$this->devMode) {
            return;
        }

        if (count($this->registeredSet) > 0) {
            $this->updateAliasMap();
            $this->exportAliasMap();
        }
    }

    /**
     * @return void
     */
    protected function updateAliasMap(): void
    {
        $registered = array_keys($this->registeredSet);

        // check for added commands
        $addedCommands = array_diff($registered, $this->aliasMap);
        foreach ($addedCommands as $class) {
            $name = $class::getDefinition()->getName();

            if (array_key_exists($name, $this->aliasMap)) {
                throw new DuplicateEntryException($name, [
                    'name' => $name,
                    'new_class' => $class,
                    'existing_class' => $this->aliasMap[$name],
                ]);
            }

            $this->aliasMap[$name] = $class;
        }

        // check for removed commands
        $deleted = array_keys(array_diff($this->aliasMap, $registered));
        foreach ($deleted as $name) {
            unset($this->aliasMap[$name]);
        }
    }

    /**
     * @return bool
     */
    protected function importAliasMap(): bool
    {
        $cacheFilePath = $this->getAliasMapCachePath();
        if (file_exists($cacheFilePath)) {
            $this->aliasMap = require $cacheFilePath;
            return true;
        }
        return false;
    }

    /**
     * @return void
     */
    protected function exportAliasMap(): void
    {
        if (!file_exists($this->cacheDir)) {
            mkdir($this->cacheDir, 0777, true);
        }

        file_put_contents($this->getAliasMapCachePath(), implode("\n", [
            '<?php declare(strict_types=1);',
            '',
            '/*',
            ' * This file is auto-generated by ' . __CLASS__ . '. Do not edit this file manually.',
            ' */',
            'return ' . var_export($this->aliasMap, true) . ';',
            '',
        ]));
    }
}
